<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:media="http://search.yahoo.com/mrss/"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:georss="http://www.georss.org/georss">

  <channel>
    <title>
      <![CDATA[  Emanuel Castelo  ]]>
    </title>
    <link> https://elvcastelo.github.io </link>
    <description>
      <![CDATA[  Personal website of Emanuel Castelo  ]]>
    </description>
    <atom:link
      href="https://elvcastelo.github.io/blog/feed.xml"
      rel="self"
      type="application/rss+xml" />
    <generator>
        Franklin.jl - https://github.com/tlienart/Franklin.jl
    </generator>


<item>
  <title>
    <![CDATA[  O problema do caminho mínimo com no máximo k cores  ]]>
  </title>
  <link> https://elvcastelo.github.io/blog/solving-kcsp-problem/index.html </link>
  <guid isPermaLink="true"> https://elvcastelo.github.io/blog/solving-kcsp-problem/index.html </guid>
  <description>
    <![CDATA[  Discutiremos o problema de encontrar um caminho de custo mínimo em um grafo ponderado com coloração de arestas. Trata-se de um problema NP-difícil.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<h1 id="o_problema_do_caminho_mínimo_com_no_máximo_k_cores">O problema do caminho mínimo com no máximo k cores</h1>
<p>Nesta postagem trataremos do problema que foi foco da minha dissertação de mestrado na Universidade Federal do Ceará &#40;UFC&#41;, sob orientação do Prof. <a href="https://scholar.google.com/citations?hl&#61;en&amp;user&#61;7gbgIFsAAAAJ&amp;view_op&#61;list_works&amp;sortby&#61;pubdate">Rafael Castro de Andrade</a> &#40;UFC&#41; e co-orientação do Prof. <a href="https://scholar.google.com/citations?hl&#61;en&amp;user&#61;HbVMz8UAAAAJ&amp;view_op&#61;list_works&amp;sortby&#61;pubdate">Rommel Dias Saraiva</a> &#40;Universidade de Fortaleza, UNIFOR&#41;.</p>
<p>O leitor interessado em mais detalhes pode conferir a <a href="https://repositorio.ufc.br/bitstream/riufc/73496/3/2023_dis_eescastelo.pdf">dissertação</a> diretamente no site da UFC e o <a href="https://www.sciencedirect.com/science/article/abs/pii/S0377221723009487">artigo</a> publicado no European Journal of Operational Research este ano.</p>
<p>Conceitos fundamentais são definidos de forma breve. Ao decorrer do texto poderão ser encontradas notas de rodapé com maiores detalhes ou referências ao que está sendo lidado no documento.</p>
<h2 id="motivação">Motivação</h2>
<p>Embora o estudo de um problema não esteja limitado a motivações práticas, traremos luz para o exemplo abaixo para motivar aqueles mais inclinados às aplicações.</p>
<p>Suponha que em uma rede de telecomunicações cada tipo de conexão seja definida por uma cor distinta. Denotamos a probabiliade de falha de uma conexão do tipo \(h\) por \(p_{h}\). Para fins de simplicidade, assumimos \(p_{h} = 1 / T\) para todo tipo de conexão \(h\), onde \(T\) é o total de conexões. Note que todas as conexões deste tipo falham ao mesmo tempo. Este é o caso, por exemplo, quando todas estas conexões representam cabos ethernet conectados a um determinado roteador.</p>
<p>Os gestores desta rede de telecomunicações desejam interligar dois pontos \(A\) e \(B\) da rede tal que o caminho entre eles tenha probabilidade mínima de falha. Isto é o que equivalente a dizer que o caminho entre estes pontos deve utilizar a menor quantidade de cores possível &#40;por quê?&#41;. As cores, portanto, possuem o papel de mensurar a resiliência da rede.</p>
<p>Após uma reunião com os técnicos da empresa foi decidido que uma probabilidade de falha \(p = k / T\) no caminho, onde \(0 \leq k \leq T\), é considerada aceitável para a natureza das atividades da empresa. Em nosso cenário isto é equivalente a dizer que o caminho pode possuir no máximo \(k\) cores distintas &#40;por quê?&#41;. Por fim, a empresa também deseja minimizar o custo da rota.</p>
<p>O exemplo acima trata de uma possível aplicação do problema de encontrar um caminho mínimo entre um par de vértices em um grafo ponderado com coloração de arestas tal que o caminho contenha no máximo \(k\) cores distintas. O leitor também pode imaginar um cenário onde cada cor codifica uma licença. O pagamento pela licença é realizada uma única vez, no momento em que a cor correspondente passa a fazer parte da solução.</p>
<p>Além de aplicações em redes de telecomunicações, o problema também possui aplicações na robótica<sup id="fnref:1">[1]</sup> e em redes de transportes<sup id="fnref:2">[2]</sup>. Problemas semelhantes definidos na mesma estrutura de grafos encontram suas aplicações em biologia computacional<sup id="fnref:3">[3]</sup>.</p>
<p><table class="fndef" id="fndef:1">
    <tr>
        <td class="fndef-backref">[1]</td>
        <td class="fndef-content">Eiben, E., &amp; Kanj, I. &#40;2020&#41;. A colored path problem and its applications. ACM Transactions on Algorithms &#40;TALG&#41;, 16&#40;4&#41;, 1-48.</td>
    </tr>
</table>
<table class="fndef" id="fndef:2">
    <tr>
        <td class="fndef-backref">[2]</td>
        <td class="fndef-content">Dehouche, N. &#40;2020&#41;. The k-interchange-constrained diameter of a transit network: a connectedness indicator that accounts for travel convenience. Transportation Letters, 12&#40;3&#41;, 197-201.</td>
    </tr>
</table>
<table class="fndef" id="fndef:3">
    <tr>
        <td class="fndef-backref">[3]</td>
        <td class="fndef-content">Pevzner, P. A. &#40;1995&#41;. DNA physical mapping and alternating Eulerian cycles in colored graphs. Algorithmica, 13&#40;1&#41;, 77-105.</td>
    </tr>
</table>
</p>
<h2 id="definição">Definição</h2>
<p>Considere a definição do problema abaixo, onde \(V\) é o conjunto de vértices, \(E\) o conjunto de arestas, \(w: E \rightarrow \mathbb{R}_{+}\) a função de custo das arestas, e \(c: E \rightarrow \mathbb{N}\) a função de coloração de arestas. Note que \(k\) é um inteiro positivo.</p>
<div class="definition"><strong>Definição</strong>: &#40;<em>\(k\)-Colour Shortest Path ou \(k\)-CSP</em>&#41;    Dado um grafo<sup id="fnref:4">[4]</sup><sup id="fnref:5">[5]</sup> ponderado com coloração de arestas \(G = (V, E, w, c)\) e um par de vértices \(s, t \in V\), o problema \(k\)-Colour Shortest Path consiste em obter um \(st\)-caminho de custo mínimo em \(G\) contendo no máximo \(k\) cores distintas.</div>
<p>Chamamos de <em>\(st\)-caminho</em> um caminho em \(G\) partindo do vértice \(s\) ao vértice \(t\). Estes vértices são chamados de <em>fonte</em> e <em>sumidouro</em>, respectivamente.</p>
<div class="proposition"><strong>Proposição</strong>:  O \(k\)-Colour Shortest Path é \(\mathbf{NP}\)-difícil<sup id="fnref:6">[6]</sup><sup id="fnref:7">[7]</sup>.</div>
<a id="figexemplo_kcsp" class="anchor"></a>
<img src="https://elvcastelo.github.io/assets/blog/solving-kcsp-problem/exemplo_kcsp.svg" alt="">
<p>Observemos o exemplo dado na figura acima. Sejam \(A\) e \(D\) os vértices de origem e destino, respectivamente, e definamos \(k = 2\) como o limite de cores. Note que o \(AD\)-caminho de custo mínimo é dado pela sequência \(A \rightarrow B \rightarrow E \rightarrow C \rightarrow D\) de custo \(8\). Todavia, este caminho utiliza três cores &#40;vermelho, azul, e verde&#41;, portanto, não é considerado uma solução viável para o nosso problema. O leitor poderá conferir que a &#40;única&#41; solução ótima para nossa instância é dada pelo caminho \(A \rightarrow C \rightarrow D\) de custo \(10\), que utiliza duas cores distintas.</p>
<p><table class="fndef" id="fndef:4">
    <tr>
        <td class="fndef-backref">[4]</td>
        <td class="fndef-content">Um exemplo de grafo ponderado pode ser visto na figura acima, onde \(V = \{A, B, C, D, E\}\) e \(E = \{AB, AC, BE, CE, CD\}\).</td>
    </tr>
</table>
<table class="fndef" id="fndef:5">
    <tr>
        <td class="fndef-backref">[5]</td>
        <td class="fndef-content">O leitor interessado poderá consultar o <a href="https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphs.html">material escrito</a> de <a href="https://www.ime.usp.br/~pf/">Paulo Feofiloff</a> sobre definições básicas de grafos e grafos direcionados, e as <a href="https://www.youtube.com/watch?v&#61;kfHqZLYHfHU&amp;list&#61;PLndfcZyvAqbr2MLCOLEvBNX6FgD8UNWfX">video-aulas de Teoria dos Grafos</a> do professor <a href="https://mdcc.ufc.br/pt/corpo-docente/victor-almeida-campos/">Victor Campos</a>.</td>
    </tr>
</table>
<table class="fndef" id="fndef:6">
    <tr>
        <td class="fndef-backref">[6]</td>
        <td class="fndef-content">Ferone, D., Festa, P., &amp; Pastore, T. &#40;2019&#41;. The k-color shortest path problem. Advances in Optimization and Decision Science for Society, Services and Enterprises: ODS, Genoa, Italy, September 4-7, 2019, 367-376.</td>
    </tr>
</table>
<table class="fndef" id="fndef:7">
    <tr>
        <td class="fndef-backref">[7]</td>
        <td class="fndef-content">A versão de decisão do \(k\)-CSP pode ser visto como uma generalização da versão de decisão do problema de encontrar um caminho com quantidade mínima de cores &#40;MCP, do inglês <em>Minimum Colour Path</em>&#41;.</td>
    </tr>
</table>
</p>
<h2 id="métodos_de_resolução_heurísticas">Métodos de resolução: heurísticas?</h2>
<p>Como visto, o problema é facilmente definido. Nesta seção trataremos de uma forma de lidar com este problema e outros problemas \(\mathbf{NP}\)-difíceis em geral.</p>
<p>Um algoritmo \(\mathcal{A}\) é dito ser uma <em>heurística</em> para o problema \(\Pi\) se dado uma instância \(I\) de \(\Pi\), \(\mathcal{A}(I)\) retorna uma solução viável. Perceba que não há necessariamente garantias na qualidade da solução retornada, diferentemente do que ocorre na criação de <em>algoritmos aproximativos</em>. Embora propor uma heurística seja muito dependente do problema, há algumas estratégias comumente empregadas para o design de heurísticas eficientes na prática. O leitor interessado poderá consultar as referências recomendadas<sup id="fnref:8">[8]</sup><sup id="fnref:9">[9]</sup>.</p>
<p>Dada esta introdução, voltemos para o \(k\)-CSP. Como poderíamos propor uma heurística para este problema? Note que ao não nos importamos pela qualidade da solução podemos descartar a noção de que o caminho deve ter custo mínimo. Nosso objetivo é, portanto, meramente encontrar um caminho com no máximo \(k\) cores distintas.</p>
<div class="definition"><strong>Definição</strong>: &#40;<em>\(k\)-Colour Path</em>&#41;    Dado um grafo com coloração de arestas \(G = (V, E, c)\) e um par de vértices \(s, t \in V\), o \(k\)-Colour Path consiste em obter um \(st\)-caminho em \(G\) contendo no máximo \(k\) cores distintas.</div>
<p>A proposição abaixo, no entanto, apresenta-se como um obstáculo para a criação de uma heurística para este problema. O corolário segue imediatamente deste resultado.</p>
<div class="proposition"><strong>Proposição</strong>:  O problema de decidir se há uma solução para o \(k\)-Colour Path é \(\mathbf{NP}\)-completo<sup id="fnref:10">[10]</sup>.</div>
<p>A implicação deste resultado é que não há um algoritmo que, em tempo \(O(n^{c})\) para algum \(c \geq 1\), retorne uma solução viável o nosso problema a menos que \(\mathbf{P} = \mathbf{NP}\).</p>
<div class="corollary"><strong>Corolário</strong>:  Não há um algoritmo aproximativo em tempo polinomial para o \(k\)-CSP, a menos que \(\mathbf{P} = \mathbf{NP}\).</div>
<p>Isto não significa que não podemos fazer algo&#33; Em 2023, os pesquisadores Cerrone e Russo propuseram um algoritmo pseudopolynomial para o problema com complexidade de tempo \(O(|L| n^{2})\) para um dado conjunto \(L\) que definiremos adiante<sup id="fnref:11">[11]</sup>. O algoritmo, no entanto, nem sempre é capaz de retornar uma solução, e podemos facilmente construir classes de instâncias em que esse fenômeno ocorre<sup id="fnref:12">[12]</sup>. Aos curiosos, detalharemos o funcionamento desta heurística a seguir.</p>
<h3 id="o_algoritmo_de_cerrone_e_russo_2023">O algoritmo de Cerrone e Russo &#40;2023&#41;</h3>
<p>Ignoremos as cores atribuidas às arestas. Para a obtenção de um caminho de custo mínimo em um grafo ponderado normalmente empregaríamos o algoritmo de Dijkstra<sup id="fnref:13">[13]</sup>, que executa em tempo \(O(n^{2})\) em uma simples implementação com fila de prioridade.</p>
<p>E se além de levarmos em consideração o peso das arestas nós pudéssemos atribuir uma penalidade \(\lambda\) a cada nova cor? A ideia é a seguinte: podemos acrescentar \(\lambda\) ao custo da aresta sendo visitada se e somente se a cor desta aresta não tiver ocorrido no caminho até o momento. Esta estratégia visa &quot;desmotivar&quot; o algoritmo a escolher caminhos que introduzem novas cores. Cerrone e Russo &#40;2023&#41; definem uma lista \(L\) de penalidades, e para todo \(\lambda \in L\) executamos nossa modificação do algoritmo de Dijkstra.</p>
<p>Abaixo o leitor poderá conferir o passo-a-passo do algoritmo executado em um grafo direcionado<sup id="fnref:14">[14]</sup> para \(k = 2\). Perceba que para \(\lambda \leq 4\) a heurística retorna o caminho \(s \rightarrow 3 \rightarrow 4 \rightarrow t\) como solução, embora esta não seja uma solução viável.</p><figure class="blogpost_figure">
<img src="https://elvcastelo.github.io/assets/blog/solving-kcsp-problem/exemplo_heuristica_passo1.svg"/>
<figcaption><strong>Passo 1:</strong> Iniciando do vértice fonte, prosseguimos para um vértice vizinho, destacado na imagem acima. Perceba que como a cor vermelha ainda não foi utilizada para alcançar o nó de rótulo 3, nós acrescentamos a penalidade ao custo do arco.</figcaption>
</figure><figure class="blogpost_figure">
<img src="https://elvcastelo.github.io/assets/blog/solving-kcsp-problem/exemplo_heuristica_passo2.svg"/>
<figcaption><strong>Passo 2:</strong> Visitamos o próximo vizinho da fonte e seguimos com o mesmo raciocínio da etapa anterior.</figcaption>
</figure><figure class="blogpost_figure">
<img src="https://elvcastelo.github.io/assets/blog/solving-kcsp-problem/exemplo_heuristica_passo3.svg"/>
<figcaption><strong>Passo 3:</strong> Ao visitarmos o próximo vértice, percebemos que a cor azul ainda não foi utilizada, e portanto, a penalidade é adicionado ao arco. </figcaption>
</figure><figure class="blogpost_figure">
<img src="https://elvcastelo.github.io/assets/blog/solving-kcsp-problem/exemplo_heuristica_passo4.svg"/>
<figcaption><strong>Passo 4:</strong> O mesmo ocorre no caminho acima.</figcaption>
</figure><figure class="blogpost_figure">
<img src="https://elvcastelo.github.io/assets/blog/solving-kcsp-problem/exemplo_heuristica_passo5.svg"/>
<figcaption><strong>Passo 5:</strong> Seguimos com o mesmo procedimento para o arco laranja.</figcaption>
</figure><figure class="blogpost_figure">
<img src="https://elvcastelo.github.io/assets/blog/solving-kcsp-problem/exemplo_heuristica_passo6.svg"/>
<figcaption><strong>Passo 6:</strong> Entretanto, perceba agora que como um arco de cor vermelha já ocorre no caminho de cima, uma penalidade não será adicionada no último arco visitado.</figcaption>
</figure><p>Embora o algoritmo acima nem sempre seja capaz de retornar uma solução viável, os autores obtiveram bons resultados nas instâncias propostas na literatura anterior ao nosso trabalho<sup id="fnref:6">[6]</sup><sup id="fnref:11">[11]</sup><sup id="fnref:12">[12]</sup><sup id="fnref:15">[15]</sup>. A introdução de novas heurísticas ainda é um problema em aberto.</p>
<p><table class="fndef" id="fndef:8">
    <tr>
        <td class="fndef-backref">[8]</td>
        <td class="fndef-content">Talbi, E. G. &#40;2009&#41;. Metaheuristics: from design to implementation. John Wiley &amp; Sons.</td>
    </tr>
</table>
<table class="fndef" id="fndef:9">
    <tr>
        <td class="fndef-backref">[9]</td>
        <td class="fndef-content">Mart, R., Pardalos, P. M., &amp; Resende, M. G. &#40;2018&#41;. Handbook of heuristics. Springer Publishing Company, Incorporated.</td>
    </tr>
</table>
<table class="fndef" id="fndef:10">
    <tr>
        <td class="fndef-backref">[10]</td>
        <td class="fndef-content">Broersma, H., Li, X., Woeginger, G., &amp; Zhang, S. &#40;2005&#41;. Paths and cycles in colored graphs. Australasian journal of combinatorics, 31&#40;1&#41;, 299-311.</td>
    </tr>
</table>
<table class="fndef" id="fndef:11">
    <tr>
        <td class="fndef-backref">[11]</td>
        <td class="fndef-content">Cerrone, C., &amp; Russo, D. D. &#40;2023&#41;. An exact reduction technique for the k-Colour Shortest Path Problem. Computers &amp; Operations Research, 149, 106027.</td>
    </tr>
</table>
<table class="fndef" id="fndef:12">
    <tr>
        <td class="fndef-backref">[12]</td>
        <td class="fndef-content">Castelo, E. &#40;2023&#41;. Contributions to the k-color shortest path problem. Master&#39;s thesis, Universidade Federal do Ceará.</td>
    </tr>
</table>
<table class="fndef" id="fndef:13">
    <tr>
        <td class="fndef-backref">[13]</td>
        <td class="fndef-content">Dijkstra, E. &#40;1959&#41;. A Note on Two Problems in Connexion with Graphs. Numerische Mathematik, 1, 269-271.</td>
    </tr>
</table>
<table class="fndef" id="fndef:14">
    <tr>
        <td class="fndef-backref">[14]</td>
        <td class="fndef-content">Ao leitor que não saiba distiguir um grafo de um <em>grafo direcionado</em>, também apelidado de digrafo, basta imaginar que agora as arestas possuem direções. Neste caso, \(AB\) é uma aresta direcionada do vértice \(A\) ao vértice \(B\). Não seria possível percorrer esta aresta na direção oposta. Arestas direcionadas são chamadas de <em>arcos</em>.</td>
    </tr>
</table>
<table class="fndef" id="fndef:15">
    <tr>
        <td class="fndef-backref">[15]</td>
        <td class="fndef-content">de Andrade, R. C., Castelo, E. E. S., &amp; Saraiva, R. D. &#40;2024&#41;. Valid inequalities for the k-Color Shortest Path Problem. European Journal of Operational Research, 315&#40;2&#41;, 499-510.</td>
    </tr>
</table>
</p>
<h2 id="métodos_de_resolução_programação_linear_inteira">Métodos de resolução: programação linear inteira</h2>
<p>Nesta seção trataremos de como resolver problemas \(\mathbf{NP}\)-difíceis de forma exata em otimização combinatória ao tratarmos estes problemas como um problema de Programação Linear Inteira. Para mais informações sobre Programação Linear e Programação Linear Inteira confira as referência no rodapé<sup id="fnref:16">[16]</sup><sup id="fnref:17">[17]</sup><sup id="fnref:18">[18]</sup>.</p>
<p>Antes de começarmos, construiremos uma instância equivalente representada pelo grafo direcionado ponderado com coloração de arcos \(D = (V, A, w', c')\) de modo a simplificar o modelo matemático. Relembramos o leitor que recebemos como entrada o grafo ponderado com coloração de arestas \(G = (V, E, w, c)\). Para toda aresta \(uv \in E\) adicionaremos os arcos \(uv\) e \(vu\) ao conjunto \(A\), onde \(w'(uv) = w'(vu) = w(uv)\) e \(c'(uv) = c'(vu) = c(uv)\).</p>
<div class="example"><p><strong>Exemplo</strong>: &#40;<em>Representação de Grafos como Grafos Direcionados</em>&#41;    Considere o grafo na figura abaixo.</p>
<img src="https://elvcastelo.github.io/assets/blog/solving-kcsp-problem/exemplo_orientacao1.svg" alt="">
<p>Para toda aresta, adicionamos dois arcos em direções opostas, obtendo o grafo direcionado abaixo.</p>
<img src="https://elvcastelo.github.io/assets/blog/solving-kcsp-problem/exemplo_orientacao2.svg" alt="">
<p>Perceba que as cores e custos &#40;neste exemplo toda aresta possui custo unitário&#41; dos arcos são os mesmos da aresta na qual eles representam.</p></div>
<p>Note que o \(k\)-CSP é um problema de minimização. O primeiro passo é codificar o objetivo do problema como uma função. Lembre-se que o objetivo do \(k\)-CSP é encontrar um caminho de custo mínimo, portanto, definiremos as seguintes variáveis binárias para toda aresta \(uv \in E\) que serão úteis logo a seguir.</p>
\[
  x_{uv} = \begin{cases}
      1 & \text{se o arco } uv \text{ pertence à solução}, \\
      0 & \text{caso contrário.}
    \end{cases}
\]
<p>Seguiremos com um breve abuso de notação ao definirmos \(w_{uv} = w'(uv)\) como o custo do arco \(uv\) para melhor visualização das equações a seguir.</p>
\[
  \min_{x} \sum_{uv \in A} w_{uv} x_{uv}
\]
<p>O leitor atencioso deve notar que limitar-nos apenas a minimizar a função acima não garante que os valores escolhidos definirão um caminho. De fato, podemos definir \(x = \mathbf{0}^{m}\), onde \(\mathbf{0}^{m}\) é um vetor \(m\)-dimensional de zeros e \(m = |A|\) é a quantidade de arcos no digrafo. Precisamos garantir que os valores de \(x\) formem um caminho. Para isto, adicionaremos o que é conhecido na literatura como <em>restrições de fluxo</em>.</p>
<p>Antes de continuarmos, definimos \(N^{+}(u)\) para um dado vértice \(u\) como a vizinhança de saída de \(u\). Esta notação simboliza o conjunto de vértices tal que para todo \(v \in N^{+}(u)\) temos \(uv \in A\). A vizinhança de entrada \(N^{-}(u)\) é definida de forma análoga. A igualdade abaixo deve ser satisfeita para todo vértice.</p>
\[
  \sum_{v \in N^{-}(u)} x_{vu} - \sum_{v \in N^{+}(u)} x_{uv} = \begin{cases}
    -1 & \text{se } u = s, \\
    +1 & \text{se } u = t, \\
    \phantom{+}0 & \text{caso contrário}.
  \end{cases}, \quad \forall \; u \in V
\]
<p>As desigualdades acima funcionam da seguinte maneira. Imagine as arestas do grafo como canos em uma rede hidraúlica, onde o fluxo do líquido começa na fonte \(s\). Caso desejemos que o líquido chegue ao sumidouro \(t\) devemos impor algumas restrições: o fluxo apenas sai da fonte; o fluxo apenas chega ao sumidouro; para toda outra interseção na rede, isto é, vértices do grafo, todo fluxo que entra também deve sair.</p>
<p>Agora vamos codificar o uso de cores&#33; Definiremos a variável binária \(y_{h}\) conforme descrito abaixo para toda cor \(h\) existente no digrafo.</p>
\[
  y_{h} = \begin{cases}
      1 & \text{se a cor } h \text{ pertence à solução}, \\
      0 & \text{caso contrário.}
    \end{cases}
\]
<p>Por definição, a soma dessas variáveis deve ser menor ou igual a \(k\), portanto a restrição abaixo surge naturalmente. Por simplicidade, denotaremos por \(C = \{c'(uv) \mid uv \in A\}\) o conjunto de todas as cores no digrafo. Esse tipo de restrição também é conhecida como <em>restrição de mochila</em>, em referência ao Problema da Mochila<sup id="fnref:19">[19]</sup>.</p>
\[
  \sum_{h \in C} y_{h} \leq k
\]
<p>Agora, precisamos garantir que utilizar um arco implique o uso de sua cor. Para isso o leitor pode derivar a desigualdade abaixo utilizando seu conhecimento de lógica<sup id="fnref:20">[20]</sup>.</p>
\[
  x_{uv} \leq y_{h}, \; \forall \; uv \in A \mid c'(uv) = h
\]
<p>O nosso modelo matemático está completo&#33; Para fácil visualização juntaremos todas as desigualdades derivadas até o momento.</p>
\[
  \begin{align*}
    \min_{x} & \sum_{uv \in E} w_{uv} x_{uv} \\
    & \sum_{v \in N^{-}(u)} x_{vu} - \sum_{v \in N^{+}(u)} x_{uv} = \begin{cases}
      -1 & \text{se } u = s, \\
      +1 & \text{se } u = t, \\
      \phantom{+}0 & \text{caso contrário}.
    \end{cases}, \; \forall \; u \in V \\
    & \sum_{h \in C} y_{h} \leq k \\
    & x_{uv} \leq y_{h}, \; \forall \; uv \in A \mid c'(uv) = h \\
    & x_{uv} \in \{0, 1\}, \; \forall \; uv \in A \\
    & y_{h} \in \{0, 1\}, \; \forall \; h \in C
  \end{align*}
\]
<p>O modelo acima pode ser resolvido por meio de <em>solvers</em> matemáticos como CPLEX<sup id="fnref:21">[21]</sup>, Gurobi<sup id="fnref:22">[22]</sup>, e até mesmo gratuitos como GLPK<sup id="fnref:23">[23]</sup>. O leitor pode decidir implementar estes modelos tanto diretamente em software especializado quanto em uma linguagem de programação como Python e Julia utilizando as bibliotecas adequadas<sup id="fnref:24">[24]</sup><sup id="fnref:25">[25]</sup>.</p>
<p>Nem sempre o uso de modelos matemáticos nos possibilita resolver instâncias de tamanhos razoáveis em tempo razoável<sup id="fnref:26">[26]</sup>. Para isso podemos melhorar o modelo matemático acima com o uso de <em>desigualdades válidas</em>. De forma breve, desigualdades válidas são desigualdades que são satisfeitas por qualquer solução viável do problema.</p>
<p>Um exemplo de desigualdade válida encontra-se logo abaixo, fruto de meu trabalho de mestrado<sup id="fnref:15">[15]</sup>. Em palavras, essa desigualdades implica que para todos os arcos de saída de um vértice \(u\) de mesma cor \(h\) temos que o somatório das variáveis referentes a estes arcos é no máximo o valor da variável de decisão referente a sua cor.</p>
\[
  \sum_{v \in N^{+}(u) \mid c(uv) = h} x_{uv} \leq y_{h}, \quad \forall \; u \in V
\]
<p>Longe de serem as melhores apresentadas no trabalhos, entretanto, esta desigualdade em conjunto com a desigualdade análoga para arcos de entrada já produzem resultados. Exemplo disso pode ser visto com uma instância em que o modelo original descrito acima leva 615.4 segundo para obtenção do ótimo, enquanto a aplicação das desigualdades diminui esse tempo para 521.7 segundos. Outras desigualdades descritas em nosso trabalho foram capazes de diminuir esse tempo para 41.2 segundos<sup id="fnref:15">[15]</sup>&#33;</p>
<p><table class="fndef" id="fndef:16">
    <tr>
        <td class="fndef-backref">[16]</td>
        <td class="fndef-content">Bazaraa, M. S., Jarvis, J. J., &amp; Sherali, H. D. &#40;2011&#41;. Linear programming and network flows. John Wiley &amp; Sons.</td>
    </tr>
</table>
<table class="fndef" id="fndef:17">
    <tr>
        <td class="fndef-backref">[17]</td>
        <td class="fndef-content">Wolsey, L. A. &#40;2020&#41;. Integer programming. John Wiley &amp; Sons.</td>
    </tr>
</table>
<table class="fndef" id="fndef:18">
    <tr>
        <td class="fndef-backref">[18]</td>
        <td class="fndef-content">Papadimitriou, C. H., &amp; Steiglitz, K. &#40;2013&#41;. Combinatorial optimization: algorithms and complexity. Courier Corporation.</td>
    </tr>
</table>
<table class="fndef" id="fndef:19">
    <tr>
        <td class="fndef-backref">[19]</td>
        <td class="fndef-content">https://pt.wikipedia.org/wiki/Problema&#95;da&#95;mochila</td>
    </tr>
</table>
<table class="fndef" id="fndef:20">
    <tr>
        <td class="fndef-backref">[20]</td>
        <td class="fndef-content">Busque entender o que ocorre ao escolhermos o arco \(uv\).</td>
    </tr>
</table>
<table class="fndef" id="fndef:21">
    <tr>
        <td class="fndef-backref">[21]</td>
        <td class="fndef-content">https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer</td>
    </tr>
</table>
<table class="fndef" id="fndef:22">
    <tr>
        <td class="fndef-backref">[22]</td>
        <td class="fndef-content">https://www.gurobi.com/solutions/gurobi-optimizer/</td>
    </tr>
</table>
<table class="fndef" id="fndef:23">
    <tr>
        <td class="fndef-backref">[23]</td>
        <td class="fndef-content">https://www.gnu.org/software/glpk/</td>
    </tr>
</table>
<table class="fndef" id="fndef:24">
    <tr>
        <td class="fndef-backref">[24]</td>
        <td class="fndef-content">https://www.gurobi.com/resources/discover-how-you-can-boost-your-mathematical-optimization-modeling-skills-with-python/</td>
    </tr>
</table>
<table class="fndef" id="fndef:25">
    <tr>
        <td class="fndef-backref">[25]</td>
        <td class="fndef-content">https://jump.dev/</td>
    </tr>
</table>
<table class="fndef" id="fndef:26">
    <tr>
        <td class="fndef-backref">[26]</td>
        <td class="fndef-content">A noção de tempo e tamanho de instâncias razoáveis é relativo ao problema.</td>
    </tr>
</table>
</p>
<h2 id="conclusões">Conclusões</h2>
<p>Por ser um problema recente, o \(k\)-Colour Shortest Path ainda possui muitos problemas em aberto. Além disso, existem algoritmos de branch-and-bound<sup id="fnref:6">[6]</sup> e de programação dinâmica<sup id="fnref:27">[27]</sup> propostos na literatura na qual não descorreremos sobre por ultrapassar a restrição de que este deve ser uma postagem de blog bem informal e casual.</p>
<p>Sobre este último algoritmo é curioso mencionar que o mesmo possui complexidade</p>
\[
  O\left( \left(\sum_{i=1}^{k} {|C| \choose i} \right)^{2} n\right)
\]
<p>mas consegue, em média, resolver diversas instâncias da literatura anteriores as nossas em menos de 3 segundos<sup id="fnref:27">[27]</sup>. Por se tratarem de instâncias aleatórias, o estudo da complexidade de caso médio do \(k\)-CSP é um problema em aberto.</p>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 21 Aug 2024 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Emanuel Castelo</atom:name>
  </atom:author>
    
  <category> algorithms </category>
      
</item>
</channel></rss>